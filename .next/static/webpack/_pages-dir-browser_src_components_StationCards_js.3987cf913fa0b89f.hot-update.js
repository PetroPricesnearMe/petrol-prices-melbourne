"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_src_components_StationCards_js",{

/***/ "(pages-dir-browser)/./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   baserowAPI: () => (/* binding */ baserowAPI),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Frontend Configuration\nconst config = {\n    // Baserow API Configuration\n    baserow: {\n        // Public share token (for public grids - no authentication needed)\n        publicToken: process.env.REACT_APP_BASEROW_PUBLIC_TOKEN || 'MIhg-ye0C_K99qvwTzoH6MCvTMAHLbwHR0C4aZKP674',\n        // Database token (for authenticated API access)\n        token: process.env.REACT_APP_BASEROW_TOKEN || 'G2bhijqxqtg0O05dc176fwDpaUPDSIgj',\n        apiUrl: process.env.REACT_APP_BASEROW_API_URL || 'https://api.baserow.io/api',\n        databaseId: 265358,\n        // MCP SSE URL for real-time updates\n        mcpSseUrl: process.env.REACT_APP_BASEROW_SSE_URL || 'https://api.baserow.io/mcp/ta1A1XNRrNHFLKV16tV3I0cSdkIzm9bE/sse'\n    },\n    // Backend API Configuration - ALWAYS use backend as proxy to avoid CORS issues\n    api: {\n        // Default to localhost in development, require explicit URL in production\n        baseUrl: process.env.REACT_APP_API_URL || (window.location.hostname === 'localhost' ? 'http://localhost:3001' : '/api' // Use relative path in production (assumes backend is on same domain)\n        )\n    },\n    // Baserow Table Configuration\n    tables: {\n        petrolStations: {\n            id: 623329,\n            name: 'Petrol Stations'\n        },\n        fuelPrices: {\n            id: 623330,\n            name: 'Fuel Prices'\n        },\n        airtableImport: {\n            id: 623331,\n            name: 'Airtable import report'\n        }\n    },\n    // Google Places API Configuration\n    google: {\n        placesApiKey: process.env.REACT_APP_GOOGLE_PLACES_API_KEY || 'AIzaSyDfEKO1GZBpuUuhhL-gz1miug6jdlT1nFk',\n        placesApiUrl: 'https://places.googleapis.com/v1/places:searchText',\n        mapsApiKey: process.env.REACT_APP_GOOGLE_MAPS_API_KEY || 'AIzaSyDfEKO1GZBpuUuhhL-gz1miug6jdlT1nFk'\n    },\n    // Application Settings\n    app: {\n        name: process.env.REACT_APP_APP_NAME || 'Petrol Prices Near Me',\n        description: process.env.REACT_APP_APP_DESCRIPTION || 'Melbourne Petrol Stations'\n    }\n};\n// Utility functions for Baserow API calls\nconst baserowAPI = {\n    /**\n   * Fetch with exponential backoff retry logic\n   * @param {string} url - URL to fetch\n   * @param {object} options - Fetch options\n   * @param {number} maxRetries - Maximum number of retries\n   * @returns {Promise<Response>} Fetch response\n   */ async fetchWithRetry (url, options = {}, maxRetries = 3) {\n        let lastError;\n        for(let attempt = 0; attempt < maxRetries; attempt++){\n            try {\n                // Add timeout to each attempt\n                const controller = new AbortController();\n                const timeoutId = setTimeout(()=>controller.abort(), 15000); // 15 second timeout\n                const response = await fetch(url, {\n                    ...options,\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                // Handle rate limiting (429)\n                if (response.status === 429) {\n                    const retryAfter = response.headers.get('Retry-After');\n                    const waitTime = retryAfter ? parseInt(retryAfter) * 1000 : Math.pow(2, attempt) * 1000;\n                    if (true) {\n                        console.warn(`‚ö†Ô∏è Rate limited (429). Waiting ${waitTime / 1000}s before retry...`);\n                    }\n                    await new Promise((resolve)=>setTimeout(resolve, waitTime));\n                    continue;\n                }\n                // Don't retry client errors (except 429) \n                if (response.status >= 400 && response.status < 500 && response.status !== 429) {\n                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                }\n                // Success or server error (which we should retry)\n                if (response.ok) {\n                    if (true) {\n                        console.log(`‚úÖ Request successful after ${attempt + 1} attempt(s)`);\n                    }\n                    return response;\n                }\n                // Server error - will retry\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            } catch (error) {\n                lastError = error;\n                // Don't retry on AbortError timeout after max retries\n                if (true) {\n                    if (error.name === 'AbortError') {\n                        console.warn(`‚ö†Ô∏è Request timeout on attempt ${attempt + 1}/${maxRetries}`);\n                    } else {\n                        console.warn(`‚ö†Ô∏è Request failed on attempt ${attempt + 1}/${maxRetries}: ${error.message}`);\n                    }\n                }\n                // If this was the last attempt, throw the error\n                if (attempt === maxRetries - 1) {\n                    if (true) {\n                        console.error(`‚ùå Request failed after ${maxRetries} attempts`);\n                    }\n                    throw lastError;\n                }\n                // Exponential backoff: 1s, 2s, 4s, 8s, etc.\n                const backoffTime = Math.pow(2, attempt) * 1000;\n                if (true) {\n                    console.log(`‚è≥ Waiting ${backoffTime / 1000}s before retry...`);\n                }\n                await new Promise((resolve)=>setTimeout(resolve, backoffTime));\n            }\n        }\n        throw lastError;\n    },\n    // Fetch all stations using the new API endpoints\n    async fetchAllStations () {\n        // In production (no backend), use direct Baserow API\n        if (!config.api.baseUrl || config.api.baseUrl === '/api') {\n            if (true) {\n                console.log('üîÑ Production mode: Using direct Baserow API...');\n            }\n            try {\n                return await this.fetchAllStationsDirect(config.tables.petrolStations.id);\n            } catch (error) {\n                if (true) {\n                    console.error('‚ùå Direct API failed:', error.message);\n                }\n                throw error;\n            }\n        }\n        try {\n            if (true) {\n                console.log(`üîÑ Fetching all stations from: ${config.api.baseUrl}/api/stations/all`);\n            }\n            // Use retry logic for backend API calls\n            const response = await this.fetchWithRetry(`${config.api.baseUrl}/api/stations/all`, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            }, 3);\n            const data = await response.json();\n            if (!data.success) {\n                throw new Error(data.error || 'Failed to fetch stations');\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully fetched ${data.data.length} stations from backend`);\n            }\n            return data.data;\n        } catch (error) {\n            if (true) {\n                console.error('‚ùå Error fetching all stations:', error.message);\n            }\n            // If backend is not available, try direct API call as fallback\n            if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch') || error.name === 'AbortError') {\n                if (true) {\n                    console.log('üîÑ Backend unavailable, trying direct Baserow API as fallback...');\n                }\n                try {\n                    return await this.fetchAllStationsDirect(config.tables.petrolStations.id);\n                } catch (directError) {\n                    if (true) {\n                        console.error('‚ùå Direct API also failed:', directError.message);\n                    }\n                    throw directError;\n                }\n            }\n            throw error;\n        }\n    },\n    // Create a new petrol station\n    async createStation (stationData) {\n        try {\n            if (true) {\n                console.log(`üîÑ Creating new station: ${stationData.stationName}`);\n            }\n            const response = await fetch(`${config.api.baseUrl}/api/stations`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(stationData),\n                signal: AbortSignal.timeout(10000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const data = await response.json();\n            if (!data.success) {\n                throw new Error(data.error || 'Failed to create station');\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully created station: ${stationData.stationName}`);\n            }\n            return data.data;\n        } catch (error) {\n            if (true) {\n                console.error('‚ùå Error creating station:', error.message);\n            }\n            throw error;\n        }\n    },\n    // Update a petrol station\n    async updateStation (stationId, updateData) {\n        try {\n            if (true) {\n                console.log(`üîÑ Updating station ${stationId}`);\n            }\n            const response = await fetch(`${config.api.baseUrl}/api/stations/${stationId}`, {\n                method: 'PUT',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify(updateData),\n                signal: AbortSignal.timeout(10000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const data = await response.json();\n            if (!data.success) {\n                throw new Error(data.error || 'Failed to update station');\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully updated station ${stationId}`);\n            }\n            return data.data;\n        } catch (error) {\n            if (true) {\n                console.error(`‚ùå Error updating station ${stationId}:`, error.message);\n            }\n            throw error;\n        }\n    },\n    // Delete a petrol station\n    async deleteStation (stationId) {\n        try {\n            if (true) {\n                console.log(`üîÑ Deleting station ${stationId}`);\n            }\n            const response = await fetch(`${config.api.baseUrl}/api/stations/${stationId}`, {\n                method: 'DELETE',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                signal: AbortSignal.timeout(10000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const data = await response.json();\n            if (!data.success) {\n                throw new Error(data.error || 'Failed to delete station');\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully deleted station ${stationId}`);\n            }\n            return true;\n        } catch (error) {\n            if (true) {\n                console.error(`‚ùå Error deleting station ${stationId}:`, error.message);\n            }\n            throw error;\n        }\n    },\n    // Get table field metadata\n    async getTableFields (tableId) {\n        try {\n            const response = await fetch(`${config.api.baseUrl}/api/baserow/fields/${tableId}`, {\n                method: 'GET',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                signal: AbortSignal.timeout(10000)\n            });\n            if (!response.ok) {\n                throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            const data = await response.json();\n            if (!data.success) {\n                throw new Error(data.error || 'Failed to fetch table fields');\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully fetched fields for table ${tableId}`);\n            }\n            return data.data;\n        } catch (error) {\n            if (true) {\n                console.error(`‚ùå Error fetching table fields:`, error.message);\n            }\n            throw error;\n        }\n    },\n    /**\n   * Fetch all stations from Baserow, handling cursor-based pagination.\n   * Note: This method should only be used as a fallback. Prefer using the backend API.\n   * @param {number|string} tableId\n   * @returns {Promise<Array>} All station rows\n   */ async fetchAllStationsDirect (tableId) {\n        if (true) {\n            console.warn('‚ö†Ô∏è Using direct Baserow API access. Consider using backend proxy instead.');\n        }\n        let rows = [];\n        // Use public token if available, otherwise use authenticated token\n        const usePublicToken = config.baserow.publicToken && config.baserow.publicToken !== 'your_public_token_here';\n        let nextUrl = usePublicToken ? `${config.baserow.apiUrl}/database/rows/table/${tableId}/?user_field_names=true&size=100&public_token=${config.baserow.publicToken}` : `${config.baserow.apiUrl}/database/rows/table/${tableId}/?user_field_names=true&size=100`;\n        if (true) {\n            console.log(`üîÑ Fetching directly from Baserow API: ${nextUrl.replace(config.baserow.publicToken, 'PUBLIC_TOKEN')}`);\n            console.log(`üìä Database ID: ${config.baserow.databaseId}`);\n            console.log(`üîë Using ${usePublicToken ? 'public token' : 'auth token'}: ${(usePublicToken ? config.baserow.publicToken : config.baserow.token).substring(0, 8)}...`);\n        }\n        try {\n            while(nextUrl){\n                if (true) {\n                    console.log(`üì° Making request to: ${nextUrl.replace(config.baserow.publicToken, 'PUBLIC_TOKEN')}`);\n                }\n                // Build headers - only add Authorization if using auth token\n                const headers = {\n                    'Content-Type': 'application/json',\n                    'Accept': 'application/json'\n                };\n                if (!usePublicToken) {\n                    headers['Authorization'] = `Token ${config.baserow.token}`;\n                }\n                // Use exponential backoff retry logic\n                const response = await this.fetchWithRetry(nextUrl, {\n                    method: 'GET',\n                    headers,\n                    mode: 'cors',\n                    credentials: 'omit'\n                }, 3);\n                const data = await response.json();\n                if (!Array.isArray(data.results)) {\n                    throw new Error('Unexpected API response structure');\n                }\n                rows.push(...data.results);\n                // Update nextUrl, preserving public_token if present\n                nextUrl = data.next ? usePublicToken ? `${data.next}&public_token=${config.baserow.publicToken}` : data.next : null;\n                if (true) {\n                    console.log(`üìä Progress: ${rows.length} stations fetched so far...`);\n                }\n            }\n            if (true) {\n                console.log(`‚úÖ Successfully fetched ${rows.length} stations from Baserow`);\n            }\n            return rows;\n        } catch (error) {\n            if (true) {\n                console.error('‚ùå Error fetching stations from Baserow:', error.message);\n            }\n            throw error;\n        }\n    },\n    // Test connection to Baserow\n    async testConnection () {\n        try {\n            const response = await fetch(`${config.api.baseUrl}/api/baserow/test`);\n            const data = await response.json();\n            return data;\n        } catch (error) {\n            if (true) {\n                console.error('Error testing connection:', error.message);\n            }\n            throw error;\n        }\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (config);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9jb25maWcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLE1BQU1BLFNBQVM7SUFDYiw0QkFBNEI7SUFDNUJDLFNBQVM7UUFDUCxtRUFBbUU7UUFDbkVDLGFBQWFDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsOEJBQThCLElBQUk7UUFDM0QsZ0RBQWdEO1FBQ2hEQyxPQUFPSCxPQUFPQSxDQUFDQyxHQUFHLENBQUNHLHVCQUF1QixJQUFJO1FBQzlDQyxRQUFRTCxPQUFPQSxDQUFDQyxHQUFHLENBQUNLLHlCQUF5QixJQUFJO1FBQ2pEQyxZQUFZO1FBQ1osb0NBQW9DO1FBQ3BDQyxXQUFXUixPQUFPQSxDQUFDQyxHQUFHLENBQUNRLHlCQUF5QixJQUFJO0lBQ3REO0lBRUEsK0VBQStFO0lBQy9FQyxLQUFLO1FBQ0gsMEVBQTBFO1FBQzFFQyxTQUFTWCxPQUFPQSxDQUFDQyxHQUFHLENBQUNXLGlCQUFpQixJQUNuQ0MsQ0FBQUEsT0FBT0MsUUFBUSxDQUFDQyxRQUFRLEtBQUssY0FBYywwQkFDMUMsT0FBUSxzRUFBc0U7UUFBekU7SUFDWDtJQUVBLDhCQUE4QjtJQUM5QkMsUUFBUTtRQUNOQyxnQkFBZ0I7WUFDZEMsSUFBSTtZQUNKQyxNQUFNO1FBQ1I7UUFDQUMsWUFBWTtZQUNWRixJQUFJO1lBQ0pDLE1BQU07UUFDUjtRQUNBRSxnQkFBZ0I7WUFDZEgsSUFBSTtZQUNKQyxNQUFNO1FBQ1I7SUFDRjtJQUVBLGtDQUFrQztJQUNsQ0csUUFBUTtRQUNOQyxjQUFjdkIsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDdUIsK0JBQStCLElBQUk7UUFDN0RDLGNBQWM7UUFDZEMsWUFBWTFCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQzBCLDZCQUE2QixJQUFJO0lBQzNEO0lBRUEsdUJBQXVCO0lBQ3ZCQyxLQUFLO1FBQ0hULE1BQU1uQixPQUFPQSxDQUFDQyxHQUFHLENBQUM0QixrQkFBa0IsSUFBSTtRQUN4Q0MsYUFBYTlCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQzhCLHlCQUF5QixJQUFJO0lBQ3hEO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDbkMsTUFBTUMsYUFBYTtJQUN4Qjs7Ozs7O0dBTUMsR0FDRCxNQUFNQyxnQkFBZUMsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxhQUFhLENBQUM7UUFDcEQsSUFBSUM7UUFFSixJQUFLLElBQUlDLFVBQVUsR0FBR0EsVUFBVUYsWUFBWUUsVUFBVztZQUNyRCxJQUFJO2dCQUNGLDhCQUE4QjtnQkFDOUIsTUFBTUMsYUFBYSxJQUFJQztnQkFDdkIsTUFBTUMsWUFBWUMsV0FBVyxJQUFNSCxXQUFXSSxLQUFLLElBQUksUUFBUSxvQkFBb0I7Z0JBRW5GLE1BQU1DLFdBQVcsTUFBTUMsTUFBTVgsS0FBSztvQkFDaEMsR0FBR0MsT0FBTztvQkFDVlcsUUFBUVAsV0FBV08sTUFBTTtnQkFDM0I7Z0JBRUFDLGFBQWFOO2dCQUViLDZCQUE2QjtnQkFDN0IsSUFBSUcsU0FBU0ksTUFBTSxLQUFLLEtBQUs7b0JBQzNCLE1BQU1DLGFBQWFMLFNBQVNNLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDO29CQUN4QyxNQUFNQyxXQUFXSCxhQUFhSSxTQUFTSixjQUFjLE9BQU9LLEtBQUtDLEdBQUcsQ0FBQyxHQUFHakIsV0FBVztvQkFDbkYsSUFBSXRDLElBQXNDLEVBQUU7d0JBQzFDd0QsUUFBUUMsSUFBSSxDQUFDLENBQUMsK0JBQStCLEVBQUVMLFdBQVcsS0FBSyxpQkFBaUIsQ0FBQztvQkFDbkY7b0JBQ0EsTUFBTSxJQUFJTSxRQUFRQyxDQUFBQSxVQUFXakIsV0FBV2lCLFNBQVNQO29CQUNqRDtnQkFDRjtnQkFFQSwwQ0FBMEM7Z0JBQzFDLElBQUlSLFNBQVNJLE1BQU0sSUFBSSxPQUFPSixTQUFTSSxNQUFNLEdBQUcsT0FBT0osU0FBU0ksTUFBTSxLQUFLLEtBQUs7b0JBQzlFLE1BQU0sSUFBSVksTUFBTSxDQUFDLEtBQUssRUFBRWhCLFNBQVNJLE1BQU0sQ0FBQyxFQUFFLEVBQUVKLFNBQVNpQixVQUFVLEVBQUU7Z0JBQ25FO2dCQUVBLGtEQUFrRDtnQkFDbEQsSUFBSWpCLFNBQVNrQixFQUFFLEVBQUU7b0JBQ2YsSUFBSTlELElBQXNDLEVBQUU7d0JBQzFDd0QsUUFBUU8sR0FBRyxDQUFDLENBQUMsMkJBQTJCLEVBQUV6QixVQUFVLEVBQUUsV0FBVyxDQUFDO29CQUNwRTtvQkFDQSxPQUFPTTtnQkFDVDtnQkFFQSw0QkFBNEI7Z0JBQzVCLE1BQU0sSUFBSWdCLE1BQU0sQ0FBQyxLQUFLLEVBQUVoQixTQUFTSSxNQUFNLENBQUMsRUFBRSxFQUFFSixTQUFTaUIsVUFBVSxFQUFFO1lBRW5FLEVBQUUsT0FBT0csT0FBTztnQkFDZDNCLFlBQVkyQjtnQkFFWixzREFBc0Q7Z0JBQ3RELElBQUloRSxJQUFzQyxFQUFFO29CQUMxQyxJQUFJZ0UsTUFBTTdDLElBQUksS0FBSyxjQUFjO3dCQUMvQnFDLFFBQVFDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixFQUFFbkIsVUFBVSxFQUFFLENBQUMsRUFBRUYsWUFBWTtvQkFDM0UsT0FBTzt3QkFDTG9CLFFBQVFDLElBQUksQ0FBQyxDQUFDLDZCQUE2QixFQUFFbkIsVUFBVSxFQUFFLENBQUMsRUFBRUYsV0FBVyxFQUFFLEVBQUU0QixNQUFNQyxPQUFPLEVBQUU7b0JBQzVGO2dCQUNGO2dCQUVBLGdEQUFnRDtnQkFDaEQsSUFBSTNCLFlBQVlGLGFBQWEsR0FBRztvQkFDOUIsSUFBSXBDLElBQXNDLEVBQUU7d0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLENBQUMsdUJBQXVCLEVBQUU1QixXQUFXLFNBQVMsQ0FBQztvQkFDL0Q7b0JBQ0EsTUFBTUM7Z0JBQ1I7Z0JBRUEsNENBQTRDO2dCQUM1QyxNQUFNNkIsY0FBY1osS0FBS0MsR0FBRyxDQUFDLEdBQUdqQixXQUFXO2dCQUMzQyxJQUFJdEMsSUFBc0MsRUFBRTtvQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyxVQUFVLEVBQUVHLGNBQWMsS0FBSyxpQkFBaUIsQ0FBQztnQkFDaEU7Z0JBQ0EsTUFBTSxJQUFJUixRQUFRQyxDQUFBQSxVQUFXakIsV0FBV2lCLFNBQVNPO1lBQ25EO1FBQ0Y7UUFFQSxNQUFNN0I7SUFDUjtJQUVBLGlEQUFpRDtJQUNqRCxNQUFNOEI7UUFDSixxREFBcUQ7UUFDckQsSUFBSSxDQUFDdEUsT0FBT2EsR0FBRyxDQUFDQyxPQUFPLElBQUlkLE9BQU9hLEdBQUcsQ0FBQ0MsT0FBTyxLQUFLLFFBQVE7WUFDeEQsSUFBSVgsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRTyxHQUFHLENBQUM7WUFDZDtZQUNBLElBQUk7Z0JBQ0YsT0FBTyxNQUFNLElBQUksQ0FBQ0ssc0JBQXNCLENBQUN2RSxPQUFPbUIsTUFBTSxDQUFDQyxjQUFjLENBQUNDLEVBQUU7WUFDMUUsRUFBRSxPQUFPOEMsT0FBTztnQkFDZCxJQUFJaEUsSUFBc0MsRUFBRTtvQkFDMUN3RCxRQUFRUSxLQUFLLENBQUMsd0JBQXdCQSxNQUFNQyxPQUFPO2dCQUNyRDtnQkFDQSxNQUFNRDtZQUNSO1FBQ0Y7UUFFQSxJQUFJO1lBQ0YsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUU8sR0FBRyxDQUFDLENBQUMsK0JBQStCLEVBQUVsRSxPQUFPYSxHQUFHLENBQUNDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztZQUNyRjtZQUVBLHdDQUF3QztZQUN4QyxNQUFNaUMsV0FBVyxNQUFNLElBQUksQ0FBQ1gsY0FBYyxDQUFDLEdBQUdwQyxPQUFPYSxHQUFHLENBQUNDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO2dCQUNuRjBELFFBQVE7Z0JBQ1JuQixTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7WUFDRixHQUFHO1lBRUgsTUFBTW9CLE9BQU8sTUFBTTFCLFNBQVMyQixJQUFJO1lBRWhDLElBQUksQ0FBQ0QsS0FBS0UsT0FBTyxFQUFFO2dCQUNqQixNQUFNLElBQUlaLE1BQU1VLEtBQUtOLEtBQUssSUFBSTtZQUNoQztZQUVBLElBQUloRSxJQUFzQyxFQUFFO2dCQUMxQ3dELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLHVCQUF1QixFQUFFTyxLQUFLQSxJQUFJLENBQUNHLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQztZQUNoRjtZQUNBLE9BQU9ILEtBQUtBLElBQUk7UUFDbEIsRUFBRSxPQUFPTixPQUFPO1lBQ2QsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLGtDQUFrQ0EsTUFBTUMsT0FBTztZQUMvRDtZQUVBLCtEQUErRDtZQUMvRCxJQUFJRCxNQUFNQyxPQUFPLENBQUNTLFFBQVEsQ0FBQyxtQkFBbUJWLE1BQU1DLE9BQU8sQ0FBQ1MsUUFBUSxDQUFDLHNCQUFzQlYsTUFBTTdDLElBQUksS0FBSyxjQUFjO2dCQUN0SCxJQUFJbkIsSUFBc0MsRUFBRTtvQkFDMUN3RCxRQUFRTyxHQUFHLENBQUM7Z0JBQ2Q7Z0JBQ0EsSUFBSTtvQkFDRixPQUFPLE1BQU0sSUFBSSxDQUFDSyxzQkFBc0IsQ0FBQ3ZFLE9BQU9tQixNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsRUFBRTtnQkFDMUUsRUFBRSxPQUFPeUQsYUFBYTtvQkFDcEIsSUFBSTNFLElBQXNDLEVBQUU7d0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLDZCQUE2QlcsWUFBWVYsT0FBTztvQkFDaEU7b0JBQ0EsTUFBTVU7Z0JBQ1I7WUFDRjtZQUVBLE1BQU1YO1FBQ1I7SUFDRjtJQUVBLDhCQUE4QjtJQUM5QixNQUFNWSxlQUFjQyxXQUFXO1FBQzdCLElBQUk7WUFDRixJQUFJN0UsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyx5QkFBeUIsRUFBRWMsWUFBWUMsV0FBVyxFQUFFO1lBQ25FO1lBRUEsTUFBTWxDLFdBQVcsTUFBTUMsTUFBTSxHQUFHaEQsT0FBT2EsR0FBRyxDQUFDQyxPQUFPLENBQUMsYUFBYSxDQUFDLEVBQUU7Z0JBQ2pFMEQsUUFBUTtnQkFDUm5CLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQTZCLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQ0o7Z0JBQ3JCL0IsUUFBUW9DLFlBQVlDLE9BQU8sQ0FBQztZQUM5QjtZQUVBLElBQUksQ0FBQ3ZDLFNBQVNrQixFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUYsTUFBTSxDQUFDLEtBQUssRUFBRWhCLFNBQVNJLE1BQU0sQ0FBQyxFQUFFLEVBQUVKLFNBQVNpQixVQUFVLEVBQUU7WUFDbkU7WUFFQSxNQUFNUyxPQUFPLE1BQU0xQixTQUFTMkIsSUFBSTtZQUVoQyxJQUFJLENBQUNELEtBQUtFLE9BQU8sRUFBRTtnQkFDakIsTUFBTSxJQUFJWixNQUFNVSxLQUFLTixLQUFLLElBQUk7WUFDaEM7WUFFQSxJQUFJaEUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRWMsWUFBWUMsV0FBVyxFQUFFO1lBQzFFO1lBQ0EsT0FBT1IsS0FBS0EsSUFBSTtRQUNsQixFQUFFLE9BQU9OLE9BQU87WUFDZCxJQUFJaEUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRUSxLQUFLLENBQUMsNkJBQTZCQSxNQUFNQyxPQUFPO1lBQzFEO1lBQ0EsTUFBTUQ7UUFDUjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1vQixlQUFjQyxTQUFTLEVBQUVDLFVBQVU7UUFDdkMsSUFBSTtZQUNGLElBQUl0RixJQUFzQyxFQUFFO2dCQUMxQ3dELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFc0IsV0FBVztZQUNoRDtZQUVBLE1BQU16QyxXQUFXLE1BQU1DLE1BQU0sR0FBR2hELE9BQU9hLEdBQUcsQ0FBQ0MsT0FBTyxDQUFDLGNBQWMsRUFBRTBFLFdBQVcsRUFBRTtnQkFDOUVoQixRQUFRO2dCQUNSbkIsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBNkIsTUFBTUMsS0FBS0MsU0FBUyxDQUFDSztnQkFDckJ4QyxRQUFRb0MsWUFBWUMsT0FBTyxDQUFDO1lBQzlCO1lBRUEsSUFBSSxDQUFDdkMsU0FBU2tCLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJRixNQUFNLENBQUMsS0FBSyxFQUFFaEIsU0FBU0ksTUFBTSxDQUFDLEVBQUUsRUFBRUosU0FBU2lCLFVBQVUsRUFBRTtZQUNuRTtZQUVBLE1BQU1TLE9BQU8sTUFBTTFCLFNBQVMyQixJQUFJO1lBRWhDLElBQUksQ0FBQ0QsS0FBS0UsT0FBTyxFQUFFO2dCQUNqQixNQUFNLElBQUlaLE1BQU1VLEtBQUtOLEtBQUssSUFBSTtZQUNoQztZQUVBLElBQUloRSxJQUFzQyxFQUFFO2dCQUMxQ3dELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLCtCQUErQixFQUFFc0IsV0FBVztZQUMzRDtZQUNBLE9BQU9mLEtBQUtBLElBQUk7UUFDbEIsRUFBRSxPQUFPTixPQUFPO1lBQ2QsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLENBQUMseUJBQXlCLEVBQUVxQixVQUFVLENBQUMsQ0FBQyxFQUFFckIsTUFBTUMsT0FBTztZQUN2RTtZQUNBLE1BQU1EO1FBQ1I7SUFDRjtJQUVBLDBCQUEwQjtJQUMxQixNQUFNdUIsZUFBY0YsU0FBUztRQUMzQixJQUFJO1lBQ0YsSUFBSXJGLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUU8sR0FBRyxDQUFDLENBQUMsb0JBQW9CLEVBQUVzQixXQUFXO1lBQ2hEO1lBRUEsTUFBTXpDLFdBQVcsTUFBTUMsTUFBTSxHQUFHaEQsT0FBT2EsR0FBRyxDQUFDQyxPQUFPLENBQUMsY0FBYyxFQUFFMEUsV0FBVyxFQUFFO2dCQUM5RWhCLFFBQVE7Z0JBQ1JuQixTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FKLFFBQVFvQyxZQUFZQyxPQUFPLENBQUM7WUFDOUI7WUFFQSxJQUFJLENBQUN2QyxTQUFTa0IsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlGLE1BQU0sQ0FBQyxLQUFLLEVBQUVoQixTQUFTSSxNQUFNLENBQUMsRUFBRSxFQUFFSixTQUFTaUIsVUFBVSxFQUFFO1lBQ25FO1lBRUEsTUFBTVMsT0FBTyxNQUFNMUIsU0FBUzJCLElBQUk7WUFFaEMsSUFBSSxDQUFDRCxLQUFLRSxPQUFPLEVBQUU7Z0JBQ2pCLE1BQU0sSUFBSVosTUFBTVUsS0FBS04sS0FBSyxJQUFJO1lBQ2hDO1lBRUEsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUU8sR0FBRyxDQUFDLENBQUMsK0JBQStCLEVBQUVzQixXQUFXO1lBQzNEO1lBQ0EsT0FBTztRQUNULEVBQUUsT0FBT3JCLE9BQU87WUFDZCxJQUFJaEUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRUSxLQUFLLENBQUMsQ0FBQyx5QkFBeUIsRUFBRXFCLFVBQVUsQ0FBQyxDQUFDLEVBQUVyQixNQUFNQyxPQUFPO1lBQ3ZFO1lBQ0EsTUFBTUQ7UUFDUjtJQUNGO0lBRUEsMkJBQTJCO0lBQzNCLE1BQU13QixnQkFBZUMsT0FBTztRQUMxQixJQUFJO1lBQ0YsTUFBTTdDLFdBQVcsTUFBTUMsTUFBTSxHQUFHaEQsT0FBT2EsR0FBRyxDQUFDQyxPQUFPLENBQUMsb0JBQW9CLEVBQUU4RSxTQUFTLEVBQUU7Z0JBQ2xGcEIsUUFBUTtnQkFDUm5CLFNBQVM7b0JBQ1AsZ0JBQWdCO2dCQUNsQjtnQkFDQUosUUFBUW9DLFlBQVlDLE9BQU8sQ0FBQztZQUM5QjtZQUVBLElBQUksQ0FBQ3ZDLFNBQVNrQixFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSUYsTUFBTSxDQUFDLEtBQUssRUFBRWhCLFNBQVNJLE1BQU0sQ0FBQyxFQUFFLEVBQUVKLFNBQVNpQixVQUFVLEVBQUU7WUFDbkU7WUFFQSxNQUFNUyxPQUFPLE1BQU0xQixTQUFTMkIsSUFBSTtZQUVoQyxJQUFJLENBQUNELEtBQUtFLE9BQU8sRUFBRTtnQkFDakIsTUFBTSxJQUFJWixNQUFNVSxLQUFLTixLQUFLLElBQUk7WUFDaEM7WUFFQSxJQUFJaEUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRTBCLFNBQVM7WUFDbEU7WUFDQSxPQUFPbkIsS0FBS0EsSUFBSTtRQUNsQixFQUFFLE9BQU9OLE9BQU87WUFDZCxJQUFJaEUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRUSxLQUFLLENBQUMsQ0FBQyw4QkFBOEIsQ0FBQyxFQUFFQSxNQUFNQyxPQUFPO1lBQy9EO1lBQ0EsTUFBTUQ7UUFDUjtJQUNGO0lBRUE7Ozs7O0dBS0MsR0FDRCxNQUFNSSx3QkFBdUJxQixPQUFPO1FBQ2xDLElBQUl6RixJQUFzQyxFQUFFO1lBQzFDd0QsUUFBUUMsSUFBSSxDQUFDO1FBQ2Y7UUFFQSxJQUFJaUMsT0FBTyxFQUFFO1FBQ2IsbUVBQW1FO1FBQ25FLE1BQU1DLGlCQUFpQjlGLE9BQU9DLE9BQU8sQ0FBQ0MsV0FBVyxJQUFJRixPQUFPQyxPQUFPLENBQUNDLFdBQVcsS0FBSztRQUNwRixJQUFJNkYsVUFBVUQsaUJBQ1YsR0FBRzlGLE9BQU9DLE9BQU8sQ0FBQ08sTUFBTSxDQUFDLHFCQUFxQixFQUFFb0YsUUFBUSw4Q0FBOEMsRUFBRTVGLE9BQU9DLE9BQU8sQ0FBQ0MsV0FBVyxFQUFFLEdBQ3BJLEdBQUdGLE9BQU9DLE9BQU8sQ0FBQ08sTUFBTSxDQUFDLHFCQUFxQixFQUFFb0YsUUFBUSxnQ0FBZ0MsQ0FBQztRQUU3RixJQUFJekYsSUFBc0MsRUFBRTtZQUMxQ3dELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLHVDQUF1QyxFQUFFNkIsUUFBUUMsT0FBTyxDQUFDaEcsT0FBT0MsT0FBTyxDQUFDQyxXQUFXLEVBQUUsaUJBQWlCO1lBQ25IeUQsUUFBUU8sR0FBRyxDQUFDLENBQUMsZ0JBQWdCLEVBQUVsRSxPQUFPQyxPQUFPLENBQUNTLFVBQVUsRUFBRTtZQUMxRGlELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLFNBQVMsRUFBRTRCLGlCQUFpQixpQkFBaUIsYUFBYSxFQUFFLEVBQUUsQ0FBQ0EsaUJBQWlCOUYsT0FBT0MsT0FBTyxDQUFDQyxXQUFXLEdBQUdGLE9BQU9DLE9BQU8sQ0FBQ0ssS0FBSyxFQUFFMkYsU0FBUyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdEs7UUFFQSxJQUFJO1lBQ0YsTUFBT0YsUUFBUztnQkFDZCxJQUFJNUYsSUFBc0MsRUFBRTtvQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRTZCLFFBQVFDLE9BQU8sQ0FBQ2hHLE9BQU9DLE9BQU8sQ0FBQ0MsV0FBVyxFQUFFLGlCQUFpQjtnQkFDcEc7Z0JBRUEsNkRBQTZEO2dCQUM3RCxNQUFNbUQsVUFBVTtvQkFDZCxnQkFBZ0I7b0JBQ2hCLFVBQVU7Z0JBQ1o7Z0JBRUEsSUFBSSxDQUFDeUMsZ0JBQWdCO29CQUNuQnpDLE9BQU8sQ0FBQyxnQkFBZ0IsR0FBRyxDQUFDLE1BQU0sRUFBRXJELE9BQU9DLE9BQU8sQ0FBQ0ssS0FBSyxFQUFFO2dCQUM1RDtnQkFFQSxzQ0FBc0M7Z0JBQ3RDLE1BQU15QyxXQUFXLE1BQU0sSUFBSSxDQUFDWCxjQUFjLENBQUMyRCxTQUFTO29CQUNsRHZCLFFBQVE7b0JBQ1JuQjtvQkFDQTZDLE1BQU07b0JBQ05DLGFBQWE7Z0JBQ2YsR0FBRztnQkFFSCxNQUFNMUIsT0FBTyxNQUFNMUIsU0FBUzJCLElBQUk7Z0JBRWhDLElBQUksQ0FBQzBCLE1BQU1DLE9BQU8sQ0FBQzVCLEtBQUs2QixPQUFPLEdBQUc7b0JBQ2hDLE1BQU0sSUFBSXZDLE1BQU07Z0JBQ2xCO2dCQUVBOEIsS0FBS1UsSUFBSSxJQUFJOUIsS0FBSzZCLE9BQU87Z0JBQ3pCLHFEQUFxRDtnQkFDckRQLFVBQVV0QixLQUFLK0IsSUFBSSxHQUFJVixpQkFBaUIsR0FBR3JCLEtBQUsrQixJQUFJLENBQUMsY0FBYyxFQUFFeEcsT0FBT0MsT0FBTyxDQUFDQyxXQUFXLEVBQUUsR0FBR3VFLEtBQUsrQixJQUFJLEdBQUk7Z0JBRWpILElBQUlyRyxJQUFzQyxFQUFFO29CQUMxQ3dELFFBQVFPLEdBQUcsQ0FBQyxDQUFDLGFBQWEsRUFBRTJCLEtBQUtqQixNQUFNLENBQUMsMkJBQTJCLENBQUM7Z0JBQ3RFO1lBQ0Y7WUFFQSxJQUFJekUsSUFBc0MsRUFBRTtnQkFDMUN3RCxRQUFRTyxHQUFHLENBQUMsQ0FBQyx1QkFBdUIsRUFBRTJCLEtBQUtqQixNQUFNLENBQUMsc0JBQXNCLENBQUM7WUFDM0U7WUFDQSxPQUFPaUI7UUFDVCxFQUFFLE9BQU8xQixPQUFPO1lBQ2QsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLDJDQUEyQ0EsTUFBTUMsT0FBTztZQUN4RTtZQUNBLE1BQU1EO1FBQ1I7SUFDRjtJQUVBLDZCQUE2QjtJQUM3QixNQUFNc0M7UUFDSixJQUFJO1lBQ0YsTUFBTTFELFdBQVcsTUFBTUMsTUFBTSxHQUFHaEQsT0FBT2EsR0FBRyxDQUFDQyxPQUFPLENBQUMsaUJBQWlCLENBQUM7WUFDckUsTUFBTTJELE9BQU8sTUFBTTFCLFNBQVMyQixJQUFJO1lBQ2hDLE9BQU9EO1FBQ1QsRUFBRSxPQUFPTixPQUFPO1lBQ2QsSUFBSWhFLElBQXNDLEVBQUU7Z0JBQzFDd0QsUUFBUVEsS0FBSyxDQUFDLDZCQUE2QkEsTUFBTUMsT0FBTztZQUMxRDtZQUNBLE1BQU1EO1FBQ1I7SUFDRjtBQUNGLEVBQUU7QUFFRixpRUFBZW5FLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcemVuYm9cXERlc2t0b3BcXFBQTk1cXHNyY1xcY29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZyb250ZW5kIENvbmZpZ3VyYXRpb25cbmNvbnN0IGNvbmZpZyA9IHtcbiAgLy8gQmFzZXJvdyBBUEkgQ29uZmlndXJhdGlvblxuICBiYXNlcm93OiB7XG4gICAgLy8gUHVibGljIHNoYXJlIHRva2VuIChmb3IgcHVibGljIGdyaWRzIC0gbm8gYXV0aGVudGljYXRpb24gbmVlZGVkKVxuICAgIHB1YmxpY1Rva2VuOiBwcm9jZXNzLmVudi5SRUFDVF9BUFBfQkFTRVJPV19QVUJMSUNfVE9LRU4gfHwgJ01JaGcteWUwQ19LOTlxdndUem9INk1DdlRNQUhMYndIUjBDNGFaS1A2NzQnLFxuICAgIC8vIERhdGFiYXNlIHRva2VuIChmb3IgYXV0aGVudGljYXRlZCBBUEkgYWNjZXNzKVxuICAgIHRva2VuOiBwcm9jZXNzLmVudi5SRUFDVF9BUFBfQkFTRVJPV19UT0tFTiB8fCAnRzJiaGlqcXhxdGcwTzA1ZGMxNzZmd0RwYVVQRFNJZ2onLFxuICAgIGFwaVVybDogcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0JBU0VST1dfQVBJX1VSTCB8fCAnaHR0cHM6Ly9hcGkuYmFzZXJvdy5pby9hcGknLFxuICAgIGRhdGFiYXNlSWQ6IDI2NTM1OCxcbiAgICAvLyBNQ1AgU1NFIFVSTCBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcbiAgICBtY3BTc2VVcmw6IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9CQVNFUk9XX1NTRV9VUkwgfHwgJ2h0dHBzOi8vYXBpLmJhc2Vyb3cuaW8vbWNwL3RhMUExWE5Sck5IRkxLVjE2dFYzSTBjU2RrSXptOWJFL3NzZSdcbiAgfSxcblxuICAvLyBCYWNrZW5kIEFQSSBDb25maWd1cmF0aW9uIC0gQUxXQVlTIHVzZSBiYWNrZW5kIGFzIHByb3h5IHRvIGF2b2lkIENPUlMgaXNzdWVzXG4gIGFwaToge1xuICAgIC8vIERlZmF1bHQgdG8gbG9jYWxob3N0IGluIGRldmVsb3BtZW50LCByZXF1aXJlIGV4cGxpY2l0IFVSTCBpbiBwcm9kdWN0aW9uXG4gICAgYmFzZVVybDogcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQSV9VUkwgfHxcbiAgICAgICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnID8gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMScgOlxuICAgICAgICAnL2FwaScpIC8vIFVzZSByZWxhdGl2ZSBwYXRoIGluIHByb2R1Y3Rpb24gKGFzc3VtZXMgYmFja2VuZCBpcyBvbiBzYW1lIGRvbWFpbilcbiAgfSxcblxuICAvLyBCYXNlcm93IFRhYmxlIENvbmZpZ3VyYXRpb25cbiAgdGFibGVzOiB7XG4gICAgcGV0cm9sU3RhdGlvbnM6IHtcbiAgICAgIGlkOiA2MjMzMjksXG4gICAgICBuYW1lOiAnUGV0cm9sIFN0YXRpb25zJ1xuICAgIH0sXG4gICAgZnVlbFByaWNlczoge1xuICAgICAgaWQ6IDYyMzMzMCxcbiAgICAgIG5hbWU6ICdGdWVsIFByaWNlcydcbiAgICB9LFxuICAgIGFpcnRhYmxlSW1wb3J0OiB7XG4gICAgICBpZDogNjIzMzMxLFxuICAgICAgbmFtZTogJ0FpcnRhYmxlIGltcG9ydCByZXBvcnQnXG4gICAgfVxuICB9LFxuXG4gIC8vIEdvb2dsZSBQbGFjZXMgQVBJIENvbmZpZ3VyYXRpb25cbiAgZ29vZ2xlOiB7XG4gICAgcGxhY2VzQXBpS2V5OiBwcm9jZXNzLmVudi5SRUFDVF9BUFBfR09PR0xFX1BMQUNFU19BUElfS0VZIHx8ICdBSXphU3lEZkVLTzFHWkJwdVV1aGhMLWd6MW1pdWc2amRsVDFuRmsnLFxuICAgIHBsYWNlc0FwaVVybDogJ2h0dHBzOi8vcGxhY2VzLmdvb2dsZWFwaXMuY29tL3YxL3BsYWNlczpzZWFyY2hUZXh0JyxcbiAgICBtYXBzQXBpS2V5OiBwcm9jZXNzLmVudi5SRUFDVF9BUFBfR09PR0xFX01BUFNfQVBJX0tFWSB8fCAnQUl6YVN5RGZFS08xR1pCcHVVdWhoTC1nejFtaXVnNmpkbFQxbkZrJ1xuICB9LFxuXG4gIC8vIEFwcGxpY2F0aW9uIFNldHRpbmdzXG4gIGFwcDoge1xuICAgIG5hbWU6IHByb2Nlc3MuZW52LlJFQUNUX0FQUF9BUFBfTkFNRSB8fCAnUGV0cm9sIFByaWNlcyBOZWFyIE1lJyxcbiAgICBkZXNjcmlwdGlvbjogcHJvY2Vzcy5lbnYuUkVBQ1RfQVBQX0FQUF9ERVNDUklQVElPTiB8fCAnTWVsYm91cm5lIFBldHJvbCBTdGF0aW9ucydcbiAgfVxufTtcblxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIEJhc2Vyb3cgQVBJIGNhbGxzXG5leHBvcnQgY29uc3QgYmFzZXJvd0FQSSA9IHtcbiAgLyoqXG4gICAqIEZldGNoIHdpdGggZXhwb25lbnRpYWwgYmFja29mZiByZXRyeSBsb2dpY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIHRvIGZldGNoXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9uc1xuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4UmV0cmllcyAtIE1heGltdW0gbnVtYmVyIG9mIHJldHJpZXNcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fSBGZXRjaCByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hXaXRoUmV0cnkodXJsLCBvcHRpb25zID0ge30sIG1heFJldHJpZXMgPSAzKSB7XG4gICAgbGV0IGxhc3RFcnJvcjtcblxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4UmV0cmllczsgYXR0ZW1wdCsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBBZGQgdGltZW91dCB0byBlYWNoIGF0dGVtcHRcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDE1MDAwKTsgLy8gMTUgc2Vjb25kIHRpbWVvdXRcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbFxuICAgICAgICB9KTtcblxuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcblxuICAgICAgICAvLyBIYW5kbGUgcmF0ZSBsaW1pdGluZyAoNDI5KVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkpIHtcbiAgICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICAgICAgY29uc3Qgd2FpdFRpbWUgPSByZXRyeUFmdGVyID8gcGFyc2VJbnQocmV0cnlBZnRlcikgKiAxMDAwIDogTWF0aC5wb3coMiwgYXR0ZW1wdCkgKiAxMDAwO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gUmF0ZSBsaW1pdGVkICg0MjkpLiBXYWl0aW5nICR7d2FpdFRpbWUgLyAxMDAwfXMgYmVmb3JlIHJldHJ5Li4uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCB3YWl0VGltZSkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgcmV0cnkgY2xpZW50IGVycm9ycyAoZXhjZXB0IDQyOSkgXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNDAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDUwMCAmJiByZXNwb25zZS5zdGF0dXMgIT09IDQyOSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1Y2Nlc3Mgb3Igc2VydmVyIGVycm9yICh3aGljaCB3ZSBzaG91bGQgcmV0cnkpXG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBSZXF1ZXN0IHN1Y2Nlc3NmdWwgYWZ0ZXIgJHthdHRlbXB0ICsgMX0gYXR0ZW1wdChzKWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXJ2ZXIgZXJyb3IgLSB3aWxsIHJldHJ5XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcblxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgLy8gRG9uJ3QgcmV0cnkgb24gQWJvcnRFcnJvciB0aW1lb3V0IGFmdGVyIG1heCByZXRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFJlcXVlc3QgdGltZW91dCBvbiBhdHRlbXB0ICR7YXR0ZW1wdCArIDF9LyR7bWF4UmV0cmllc31gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gUmVxdWVzdCBmYWlsZWQgb24gYXR0ZW1wdCAke2F0dGVtcHQgKyAxfS8ke21heFJldHJpZXN9OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgYXR0ZW1wdCwgdGhyb3cgdGhlIGVycm9yXG4gICAgICAgIGlmIChhdHRlbXB0ID09PSBtYXhSZXRyaWVzIC0gMSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIFJlcXVlc3QgZmFpbGVkIGFmdGVyICR7bWF4UmV0cmllc30gYXR0ZW1wdHNgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbGFzdEVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwb25lbnRpYWwgYmFja29mZjogMXMsIDJzLCA0cywgOHMsIGV0Yy5cbiAgICAgICAgY29uc3QgYmFja29mZlRpbWUgPSBNYXRoLnBvdygyLCBhdHRlbXB0KSAqIDEwMDA7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDij7MgV2FpdGluZyAke2JhY2tvZmZUaW1lIC8gMTAwMH1zIGJlZm9yZSByZXRyeS4uLmApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IGxhc3RFcnJvcjtcbiAgfSxcblxuICAvLyBGZXRjaCBhbGwgc3RhdGlvbnMgdXNpbmcgdGhlIG5ldyBBUEkgZW5kcG9pbnRzXG4gIGFzeW5jIGZldGNoQWxsU3RhdGlvbnMoKSB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiAobm8gYmFja2VuZCksIHVzZSBkaXJlY3QgQmFzZXJvdyBBUElcbiAgICBpZiAoIWNvbmZpZy5hcGkuYmFzZVVybCB8fCBjb25maWcuYXBpLmJhc2VVcmwgPT09ICcvYXBpJykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFByb2R1Y3Rpb24gbW9kZTogVXNpbmcgZGlyZWN0IEJhc2Vyb3cgQVBJLi4uJyk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaEFsbFN0YXRpb25zRGlyZWN0KGNvbmZpZy50YWJsZXMucGV0cm9sU3RhdGlvbnMuaWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIERpcmVjdCBBUEkgZmFpbGVkOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgRmV0Y2hpbmcgYWxsIHN0YXRpb25zIGZyb206ICR7Y29uZmlnLmFwaS5iYXNlVXJsfS9hcGkvc3RhdGlvbnMvYWxsYCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVzZSByZXRyeSBsb2dpYyBmb3IgYmFja2VuZCBBUEkgY2FsbHNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaFdpdGhSZXRyeShgJHtjb25maWcuYXBpLmJhc2VVcmx9L2FwaS9zdGF0aW9ucy9hbGxgLCB7XG4gICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9XG4gICAgICB9LCAzKTtcblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBmZXRjaCBzdGF0aW9ucycpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCAke2RhdGEuZGF0YS5sZW5ndGh9IHN0YXRpb25zIGZyb20gYmFja2VuZGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGEuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBmZXRjaGluZyBhbGwgc3RhdGlvbnM6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGJhY2tlbmQgaXMgbm90IGF2YWlsYWJsZSwgdHJ5IGRpcmVjdCBBUEkgY2FsbCBhcyBmYWxsYmFja1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ05ldHdvcmtFcnJvcicpIHx8IGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0ZhaWxlZCB0byBmZXRjaCcpIHx8IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+UhCBCYWNrZW5kIHVuYXZhaWxhYmxlLCB0cnlpbmcgZGlyZWN0IEJhc2Vyb3cgQVBJIGFzIGZhbGxiYWNrLi4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaEFsbFN0YXRpb25zRGlyZWN0KGNvbmZpZy50YWJsZXMucGV0cm9sU3RhdGlvbnMuaWQpO1xuICAgICAgICB9IGNhdGNoIChkaXJlY3RFcnJvcikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcign4p2MIERpcmVjdCBBUEkgYWxzbyBmYWlsZWQ6JywgZGlyZWN0RXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGRpcmVjdEVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvLyBDcmVhdGUgYSBuZXcgcGV0cm9sIHN0YXRpb25cbiAgYXN5bmMgY3JlYXRlU3RhdGlvbihzdGF0aW9uRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgQ3JlYXRpbmcgbmV3IHN0YXRpb246ICR7c3RhdGlvbkRhdGEuc3RhdGlvbk5hbWV9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7Y29uZmlnLmFwaS5iYXNlVXJsfS9hcGkvc3RhdGlvbnNgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoc3RhdGlvbkRhdGEpLFxuICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQoMTAwMDApXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gY3JlYXRlIHN0YXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgc3RhdGlvbjogJHtzdGF0aW9uRGF0YS5zdGF0aW9uTmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgY3JlYXRpbmcgc3RhdGlvbjonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvLyBVcGRhdGUgYSBwZXRyb2wgc3RhdGlvblxuICBhc3luYyB1cGRhdGVTdGF0aW9uKHN0YXRpb25JZCwgdXBkYXRlRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYPCflIQgVXBkYXRpbmcgc3RhdGlvbiAke3N0YXRpb25JZH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtjb25maWcuYXBpLmJhc2VVcmx9L2FwaS9zdGF0aW9ucy8ke3N0YXRpb25JZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVEYXRhKSxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDEwMDAwKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIHVwZGF0ZSBzdGF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSB1cGRhdGVkIHN0YXRpb24gJHtzdGF0aW9uSWR9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YS5kYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHVwZGF0aW5nIHN0YXRpb24gJHtzdGF0aW9uSWR9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8vIERlbGV0ZSBhIHBldHJvbCBzdGF0aW9uXG4gIGFzeW5jIGRlbGV0ZVN0YXRpb24oc3RhdGlvbklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBEZWxldGluZyBzdGF0aW9uICR7c3RhdGlvbklkfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2NvbmZpZy5hcGkuYmFzZVVybH0vYXBpL3N0YXRpb25zLyR7c3RhdGlvbklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCgxMDAwMClcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBkZWxldGUgc3RhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgZGVsZXRlZCBzdGF0aW9uICR7c3RhdGlvbklkfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgZGVsZXRpbmcgc3RhdGlvbiAke3N0YXRpb25JZH06YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLy8gR2V0IHRhYmxlIGZpZWxkIG1ldGFkYXRhXG4gIGFzeW5jIGdldFRhYmxlRmllbGRzKHRhYmxlSWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtjb25maWcuYXBpLmJhc2VVcmx9L2FwaS9iYXNlcm93L2ZpZWxkcy8ke3RhYmxlSWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDEwMDAwKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGZldGNoIHRhYmxlIGZpZWxkcycpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCBmaWVsZHMgZm9yIHRhYmxlICR7dGFibGVJZH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgZmV0Y2hpbmcgdGFibGUgZmllbGRzOmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgc3RhdGlvbnMgZnJvbSBCYXNlcm93LCBoYW5kbGluZyBjdXJzb3ItYmFzZWQgcGFnaW5hdGlvbi5cbiAgICogTm90ZTogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBhcyBhIGZhbGxiYWNrLiBQcmVmZXIgdXNpbmcgdGhlIGJhY2tlbmQgQVBJLlxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHRhYmxlSWRcbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBBbGwgc3RhdGlvbiByb3dzXG4gICAqL1xuICBhc3luYyBmZXRjaEFsbFN0YXRpb25zRGlyZWN0KHRhYmxlSWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIFVzaW5nIGRpcmVjdCBCYXNlcm93IEFQSSBhY2Nlc3MuIENvbnNpZGVyIHVzaW5nIGJhY2tlbmQgcHJveHkgaW5zdGVhZC4nKTtcbiAgICB9XG5cbiAgICBsZXQgcm93cyA9IFtdO1xuICAgIC8vIFVzZSBwdWJsaWMgdG9rZW4gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdXNlIGF1dGhlbnRpY2F0ZWQgdG9rZW5cbiAgICBjb25zdCB1c2VQdWJsaWNUb2tlbiA9IGNvbmZpZy5iYXNlcm93LnB1YmxpY1Rva2VuICYmIGNvbmZpZy5iYXNlcm93LnB1YmxpY1Rva2VuICE9PSAneW91cl9wdWJsaWNfdG9rZW5faGVyZSc7XG4gICAgbGV0IG5leHRVcmwgPSB1c2VQdWJsaWNUb2tlblxuICAgICAgPyBgJHtjb25maWcuYmFzZXJvdy5hcGlVcmx9L2RhdGFiYXNlL3Jvd3MvdGFibGUvJHt0YWJsZUlkfS8/dXNlcl9maWVsZF9uYW1lcz10cnVlJnNpemU9MTAwJnB1YmxpY190b2tlbj0ke2NvbmZpZy5iYXNlcm93LnB1YmxpY1Rva2VufWBcbiAgICAgIDogYCR7Y29uZmlnLmJhc2Vyb3cuYXBpVXJsfS9kYXRhYmFzZS9yb3dzL3RhYmxlLyR7dGFibGVJZH0vP3VzZXJfZmllbGRfbmFtZXM9dHJ1ZSZzaXplPTEwMGA7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SEIEZldGNoaW5nIGRpcmVjdGx5IGZyb20gQmFzZXJvdyBBUEk6ICR7bmV4dFVybC5yZXBsYWNlKGNvbmZpZy5iYXNlcm93LnB1YmxpY1Rva2VuLCAnUFVCTElDX1RPS0VOJyl9YCk7XG4gICAgICBjb25zb2xlLmxvZyhg8J+TiiBEYXRhYmFzZSBJRDogJHtjb25maWcuYmFzZXJvdy5kYXRhYmFzZUlkfWApO1xuICAgICAgY29uc29sZS5sb2coYPCflJEgVXNpbmcgJHt1c2VQdWJsaWNUb2tlbiA/ICdwdWJsaWMgdG9rZW4nIDogJ2F1dGggdG9rZW4nfTogJHsodXNlUHVibGljVG9rZW4gPyBjb25maWcuYmFzZXJvdy5wdWJsaWNUb2tlbiA6IGNvbmZpZy5iYXNlcm93LnRva2VuKS5zdWJzdHJpbmcoMCwgOCl9Li4uYCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChuZXh0VXJsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OhIE1ha2luZyByZXF1ZXN0IHRvOiAke25leHRVcmwucmVwbGFjZShjb25maWcuYmFzZXJvdy5wdWJsaWNUb2tlbiwgJ1BVQkxJQ19UT0tFTicpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgaGVhZGVycyAtIG9ubHkgYWRkIEF1dGhvcml6YXRpb24gaWYgdXNpbmcgYXV0aCB0b2tlblxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghdXNlUHVibGljVG9rZW4pIHtcbiAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgVG9rZW4gJHtjb25maWcuYmFzZXJvdy50b2tlbn1gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGV4cG9uZW50aWFsIGJhY2tvZmYgcmV0cnkgbG9naWNcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFJldHJ5KG5leHRVcmwsIHtcbiAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgIGNyZWRlbnRpYWxzOiAnb21pdCdcbiAgICAgICAgfSwgMyk7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YS5yZXN1bHRzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBBUEkgcmVzcG9uc2Ugc3RydWN0dXJlJyk7XG4gICAgICAgIH1cblxuICAgICAgICByb3dzLnB1c2goLi4uZGF0YS5yZXN1bHRzKTtcbiAgICAgICAgLy8gVXBkYXRlIG5leHRVcmwsIHByZXNlcnZpbmcgcHVibGljX3Rva2VuIGlmIHByZXNlbnRcbiAgICAgICAgbmV4dFVybCA9IGRhdGEubmV4dCA/ICh1c2VQdWJsaWNUb2tlbiA/IGAke2RhdGEubmV4dH0mcHVibGljX3Rva2VuPSR7Y29uZmlnLmJhc2Vyb3cucHVibGljVG9rZW59YCA6IGRhdGEubmV4dCkgOiBudWxsO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIFByb2dyZXNzOiAke3Jvd3MubGVuZ3RofSBzdGF0aW9ucyBmZXRjaGVkIHNvIGZhci4uLmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFN1Y2Nlc3NmdWxseSBmZXRjaGVkICR7cm93cy5sZW5ndGh9IHN0YXRpb25zIGZyb20gQmFzZXJvd2ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc3RhdGlvbnMgZnJvbSBCYXNlcm93OicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8vIFRlc3QgY29ubmVjdGlvbiB0byBCYXNlcm93XG4gIGFzeW5jIHRlc3RDb25uZWN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2NvbmZpZy5hcGkuYmFzZVVybH0vYXBpL2Jhc2Vyb3cvdGVzdGApO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdGVzdGluZyBjb25uZWN0aW9uOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb25maWc7ICJdLCJuYW1lcyI6WyJjb25maWciLCJiYXNlcm93IiwicHVibGljVG9rZW4iLCJwcm9jZXNzIiwiZW52IiwiUkVBQ1RfQVBQX0JBU0VST1dfUFVCTElDX1RPS0VOIiwidG9rZW4iLCJSRUFDVF9BUFBfQkFTRVJPV19UT0tFTiIsImFwaVVybCIsIlJFQUNUX0FQUF9CQVNFUk9XX0FQSV9VUkwiLCJkYXRhYmFzZUlkIiwibWNwU3NlVXJsIiwiUkVBQ1RfQVBQX0JBU0VST1dfU1NFX1VSTCIsImFwaSIsImJhc2VVcmwiLCJSRUFDVF9BUFBfQVBJX1VSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJ0YWJsZXMiLCJwZXRyb2xTdGF0aW9ucyIsImlkIiwibmFtZSIsImZ1ZWxQcmljZXMiLCJhaXJ0YWJsZUltcG9ydCIsImdvb2dsZSIsInBsYWNlc0FwaUtleSIsIlJFQUNUX0FQUF9HT09HTEVfUExBQ0VTX0FQSV9LRVkiLCJwbGFjZXNBcGlVcmwiLCJtYXBzQXBpS2V5IiwiUkVBQ1RfQVBQX0dPT0dMRV9NQVBTX0FQSV9LRVkiLCJhcHAiLCJSRUFDVF9BUFBfQVBQX05BTUUiLCJkZXNjcmlwdGlvbiIsIlJFQUNUX0FQUF9BUFBfREVTQ1JJUFRJT04iLCJiYXNlcm93QVBJIiwiZmV0Y2hXaXRoUmV0cnkiLCJ1cmwiLCJvcHRpb25zIiwibWF4UmV0cmllcyIsImxhc3RFcnJvciIsImF0dGVtcHQiLCJjb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGltZW91dElkIiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsInN0YXR1cyIsInJldHJ5QWZ0ZXIiLCJoZWFkZXJzIiwiZ2V0Iiwid2FpdFRpbWUiLCJwYXJzZUludCIsIk1hdGgiLCJwb3ciLCJjb25zb2xlIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwiRXJyb3IiLCJzdGF0dXNUZXh0Iiwib2siLCJsb2ciLCJlcnJvciIsIm1lc3NhZ2UiLCJiYWNrb2ZmVGltZSIsImZldGNoQWxsU3RhdGlvbnMiLCJmZXRjaEFsbFN0YXRpb25zRGlyZWN0IiwibWV0aG9kIiwiZGF0YSIsImpzb24iLCJzdWNjZXNzIiwibGVuZ3RoIiwiaW5jbHVkZXMiLCJkaXJlY3RFcnJvciIsImNyZWF0ZVN0YXRpb24iLCJzdGF0aW9uRGF0YSIsInN0YXRpb25OYW1lIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJBYm9ydFNpZ25hbCIsInRpbWVvdXQiLCJ1cGRhdGVTdGF0aW9uIiwic3RhdGlvbklkIiwidXBkYXRlRGF0YSIsImRlbGV0ZVN0YXRpb24iLCJnZXRUYWJsZUZpZWxkcyIsInRhYmxlSWQiLCJyb3dzIiwidXNlUHVibGljVG9rZW4iLCJuZXh0VXJsIiwicmVwbGFjZSIsInN1YnN0cmluZyIsIm1vZGUiLCJjcmVkZW50aWFscyIsIkFycmF5IiwiaXNBcnJheSIsInJlc3VsdHMiLCJwdXNoIiwibmV4dCIsInRlc3RDb25uZWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/config.js\n"));

/***/ })

});